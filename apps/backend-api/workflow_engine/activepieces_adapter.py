"""
Activepieces Workflow Engine Adapter

Implementation of the WorkflowEngine interface for Activepieces.
This adapter wraps all Activepieces API calls, providing isolation
between Bronn core and Activepieces implementation details.

If Activepieces changes or needs to be replaced, only this adapter needs updating.
"""

import os
import httpx
from typing import Dict, Any, Optional, List
from datetime import datetime

from .interface import (
    WorkflowEngine,
    WorkflowInfo,
    WorkflowStatus,
    ExecutionInfo,
    ExecutionStatus,
)
from auth.signing_key import create_activepieces_jwt


# Activepieces API base URL - must be set via environment
ACTIVEPIECES_URL = os.getenv("ACTIVEPIECES_URL", "")


def _status_from_ap(ap_status: str) -> WorkflowStatus:
    """Convert Activepieces status to internal enum."""
    mapping = {
        "DRAFT": WorkflowStatus.DRAFT,
        "ENABLED": WorkflowStatus.ACTIVE,
        "DISABLED": WorkflowStatus.PAUSED,
    }
    return mapping.get(ap_status, WorkflowStatus.DRAFT)


def _exec_status_from_ap(ap_status: str) -> ExecutionStatus:
    """Convert Activepieces execution status to internal enum."""
    mapping = {
        "SCHEDULED": ExecutionStatus.PENDING,
        "RUNNING": ExecutionStatus.RUNNING,
        "SUCCEEDED": ExecutionStatus.SUCCEEDED,
        "FAILED": ExecutionStatus.FAILED,
        "TIMEOUT": ExecutionStatus.TIMEOUT,
        "PAUSED": ExecutionStatus.PAUSED,
    }
    return mapping.get(ap_status, ExecutionStatus.PENDING)


def _workflow_from_response(data: Dict[str, Any]) -> WorkflowInfo:
    """Parse Activepieces flow response to WorkflowInfo."""
    version = data.get("version", {})
    return WorkflowInfo(
        id=data["id"],
        name=version.get("displayName", "Untitled"),
        status=_status_from_ap(data.get("status", "DRAFT")),
        project_id=data.get("projectId", ""),
        created_at=data.get("created", ""),
        updated_at=data.get("updated", ""),
        folder_id=data.get("folderId"),
    )


def _execution_from_response(data: Dict[str, Any]) -> ExecutionInfo:
    """Parse Activepieces run response to ExecutionInfo."""
    return ExecutionInfo(
        id=data["id"],
        workflow_id=data.get("flowId", ""),
        status=_exec_status_from_ap(data.get("status", "RUNNING")),
        started_at=data.get("startTime", ""),
        finished_at=data.get("finishTime"),
        duration_ms=data.get("duration"),
        error_message=data.get("error"),
    )


class ActivepiecesAdapter(WorkflowEngine):
    """
    Activepieces implementation of the WorkflowEngine interface.
    
    Uses Activepieces REST API to perform all operations.
    Authentication is handled via JWT tokens generated by Bronn.
    """
    
    def __init__(self, api_token: Optional[str] = None, timeout: float = 30.0):
        """
        Initialize the Activepieces adapter.
        
        Args:
            api_token: Optional API token for authentication
            timeout: Request timeout in seconds
        """
        self.base_url = f"{ACTIVEPIECES_URL}/v1"
        self.api_token = api_token or os.getenv("ACTIVEPIECES_API_KEY", "")
        self.timeout = timeout
    
    def _headers(self) -> Dict[str, str]:
        """Get request headers with authentication."""
        headers = {"Content-Type": "application/json"}
        if self.api_token:
            headers["Authorization"] = f"Bearer {self.api_token}"
        return headers
    
    async def _request(
        self,
        method: str,
        endpoint: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Make a request to Activepieces API."""
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            response = await client.request(
                method=method,
                url=f"{self.base_url}{endpoint}",
                headers=self._headers(),
                json=json,
                params=params,
            )
            response.raise_for_status()
            return response.json()
    
    async def create_workflow(
        self,
        name: str,
        project_id: str,
        trigger: Optional[Dict[str, Any]] = None,
        folder_id: Optional[str] = None,
    ) -> WorkflowInfo:
        """Create a new workflow in Activepieces."""
        payload = {
            "displayName": name,
            "projectId": project_id,
        }
        if folder_id:
            payload["folderId"] = folder_id
        
        data = await self._request("POST", "/flows", json=payload)
        return _workflow_from_response(data)
    
    async def get_workflow(self, workflow_id: str) -> Optional[WorkflowInfo]:
        """Get a workflow by ID from Activepieces."""
        try:
            data = await self._request("GET", f"/flows/{workflow_id}")
            return _workflow_from_response(data)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                return None
            raise
    
    async def list_workflows(
        self,
        project_id: str,
        folder_id: Optional[str] = None,
        limit: int = 50,
        cursor: Optional[str] = None,
    ) -> List[WorkflowInfo]:
        """List workflows in a project from Activepieces."""
        params = {"limit": limit}
        if folder_id:
            params["folderId"] = folder_id
        if cursor:
            params["cursor"] = cursor
        
        data = await self._request("GET", "/flows", params=params)
        flows = data.get("data", [])
        return [_workflow_from_response(f) for f in flows]
    
    async def update_workflow_status(
        self,
        workflow_id: str,
        status: WorkflowStatus,
    ) -> WorkflowInfo:
        """Update a workflow's status in Activepieces."""
        ap_status = "ENABLED" if status == WorkflowStatus.ACTIVE else "DISABLED"
        payload = {"status": ap_status}
        data = await self._request("POST", f"/flows/{workflow_id}", json=payload)
        return _workflow_from_response(data)
    
    async def delete_workflow(self, workflow_id: str) -> bool:
        """Delete a workflow from Activepieces."""
        try:
            await self._request("DELETE", f"/flows/{workflow_id}")
            return True
        except httpx.HTTPStatusError:
            return False
    
    async def execute_workflow(
        self,
        workflow_id: str,
        input_data: Optional[Dict[str, Any]] = None,
    ) -> ExecutionInfo:
        """Trigger execution of a workflow in Activepieces."""
        payload = {"flowId": workflow_id}
        if input_data:
            payload["payload"] = input_data
        
        data = await self._request("POST", "/flow-runs", json=payload)
        return _execution_from_response(data)
    
    async def get_execution_status(self, execution_id: str) -> Optional[ExecutionInfo]:
        """Get the status of a workflow execution from Activepieces."""
        try:
            data = await self._request("GET", f"/flow-runs/{execution_id}")
            return _execution_from_response(data)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                return None
            raise
    
    async def list_executions(
        self,
        workflow_id: str,
        limit: int = 50,
        cursor: Optional[str] = None,
    ) -> List[ExecutionInfo]:
        """List executions for a workflow from Activepieces."""
        params = {"flowId": workflow_id, "limit": limit}
        if cursor:
            params["cursor"] = cursor
        
        data = await self._request("GET", "/flow-runs", params=params)
        runs = data.get("data", [])
        return [_execution_from_response(r) for r in runs]


def get_workflow_engine(api_token: Optional[str] = None) -> WorkflowEngine:
    """
    Factory function to get the workflow engine instance.
    
    This enables easy swapping of engine implementations in the future.
    
    Args:
        api_token: Optional API token for authentication
        
    Returns:
        WorkflowEngine implementation (currently Activepieces)
    """
    return ActivepiecesAdapter(api_token=api_token)
